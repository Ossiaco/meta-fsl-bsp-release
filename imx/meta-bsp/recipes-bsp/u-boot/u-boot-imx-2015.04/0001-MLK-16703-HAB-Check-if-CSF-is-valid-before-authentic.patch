From 8adde4c2921d03ed43aed9fe1ad32148344c8aa0 Mon Sep 17 00:00:00 2001
From: Breno Lima <breno.lima@nxp.com>
Date: Tue, 21 Nov 2017 17:12:29 -0200
Subject: [PATCH 1/2] MLK-16703: HAB : Check if CSF is valid before
 authenticating image

For proper authentication users must check if the CSF is valid. This patch
calls the csf_is_valid function prior to authenticating the image to parse
the CSF and returns a failure if an invalid command is found as shown below.

	Authenticate image from DDR location 0x12000000...
	Check CSF for Write Data command before authenticating image

	Error - WRITE Data command found

	Authenticate zImage Fail, Please check

Backported to brach imx_v2015.04_4.1.15_1.0.0_ga.

Signed-off-by: Utkarsh Gupta <utkarsh.gupta@nxp.com>
Signed-off-by: Breno Lima <breno.lima@nxp.com>
---
 arch/arm/cpu/armv7/mx6/hab.c        | 92 +++++++++++++++++++++++++++++++++++++
 arch/arm/cpu/armv7/mx7/hab.c        | 91 ++++++++++++++++++++++++++++++++++++
 arch/arm/include/asm/arch-mx6/hab.h | 25 ++++++++++
 arch/arm/include/asm/arch-mx7/hab.h | 25 ++++++++++
 4 files changed, 233 insertions(+)

diff --git a/arch/arm/cpu/armv7/mx6/hab.c b/arch/arm/cpu/armv7/mx6/hab.c
index d6ca139..1cbc916 100644
--- a/arch/arm/cpu/armv7/mx6/hab.c
+++ b/arch/arm/cpu/armv7/mx6/hab.c
@@ -127,6 +127,92 @@ bool is_hab_enabled(void)
 	return (reg & 0x2) == 0x2;
 }
 
+/*
+ * Check whether addr lies between start and end and is within
+ * the length of the image
+ */
+static inline int chk_bounds(const uint8_t *addr, size_t bytes,
+				const uint8_t *start, const uint8_t *end)
+{
+	return (addr && (addr >= start) && (addr <= end) &&
+		((size_t)((end + 1) - addr) >= bytes))
+		? 1 : 0;
+}
+
+/* Get Length of each command in CSF */
+static inline int get_csf_cmd_hdr_len(const uint8_t *csf_hdr)
+{
+	if (*csf_hdr == HAB_CMD_HDR)
+		return sizeof(struct hab_hdr);
+
+	return HAB_HDR_LEN(*(const struct hab_hdr *)csf_hdr);
+}
+
+/*
+ * Check if CSF has Write data command
+ *
+ * If WRITE DATA command exists, then return failure
+ */
+static int csf_is_valid(int ivt_offset, ulong start_addr, size_t bytes)
+{
+	size_t offset = 0;
+	size_t cmd_hdr_len = 0;
+	size_t csf_hdr_len = 0;
+
+	const struct hab_ivt *ivt_initial = NULL;
+	const uint8_t *csf_hdr = NULL;
+	const uint8_t *end = NULL;
+	const uint8_t *start = (const uint8_t *)start_addr;
+
+	ivt_initial = (const struct hab_ivt *)(start + ivt_offset);
+
+	if (bytes != 0)
+		end = start + bytes - 1;
+	else
+		end = start;
+
+	/* Check that the CSF lies within the image bounds */
+	if ((start == 0) || (ivt_initial == NULL) ||
+	    (ivt_initial->csf == 0) ||
+	    !chk_bounds((const uint8_t *)ivt_initial->csf,
+			HAB_HDR_LEN(*(const struct hab_hdr *)ivt_initial->csf),
+			start, end)) {
+		puts("Error - CSF lies outside the image bounds\n");
+		return 0;
+	}
+
+	csf_hdr = (const uint8_t *)ivt_initial->csf;
+
+	if (*csf_hdr == HAB_CMD_HDR) {
+		csf_hdr_len = HAB_HDR_LEN(*(const struct hab_hdr *)csf_hdr);
+	} else {
+		puts("Error - CSF header command not found\n");
+		return 0;
+	}
+
+	/* Check for Write data command in CSF */
+	do {
+		switch (csf_hdr[offset]) {
+		case (HAB_CMD_WRT_DAT):
+			puts("Error - WRITE Data command found\n");
+			return 0;
+		default:
+			break;
+		}
+
+		cmd_hdr_len = get_csf_cmd_hdr_len(&csf_hdr[offset]);
+		if (!cmd_hdr_len) {
+			puts("Error - Invalid command length\n");
+			return 0;
+		}
+		offset += cmd_hdr_len;
+
+	} while (offset < csf_hdr_len);
+
+	/* Write Data command not found */
+	return 1;
+}
+
 void display_event(uint8_t *event_data, size_t bytes)
 {
 	uint32_t i;
@@ -217,6 +303,12 @@ uint32_t authenticate_image(uint32_t ddr_start, uint32_t image_size)
 
 			start = ddr_start;
 			bytes = ivt_offset + IVT_SIZE + CSF_PAD_SIZE;
+
+			puts("Check CSF for Write Data command before ");
+			puts("authenticating image\n");
+			if (!csf_is_valid(ivt_offset, start, bytes))
+				return result;
+
 #ifdef DEBUG
 			printf("\nivt_offset = 0x%x, ivt addr = 0x%x\n",
 			       ivt_offset, ddr_start + ivt_offset);
diff --git a/arch/arm/cpu/armv7/mx7/hab.c b/arch/arm/cpu/armv7/mx7/hab.c
index 43b06bd..5ab35dd 100644
--- a/arch/arm/cpu/armv7/mx7/hab.c
+++ b/arch/arm/cpu/armv7/mx7/hab.c
@@ -82,6 +82,92 @@ bool is_hab_enabled(void)
 	return (reg & 0x2000000) == 0x2000000;
 }
 
+/*
+ * Check whether addr lies between start and end and is within
+ * the length of the image
+ */
+static inline int chk_bounds(const uint8_t *addr, size_t bytes,
+				const uint8_t *start, const uint8_t *end)
+{
+	return (addr && (addr >= start) && (addr <= end) &&
+		((size_t)((end + 1) - addr) >= bytes))
+		? 1 : 0;
+}
+
+/* Get Length of each command in CSF */
+static inline int get_csf_cmd_hdr_len(const uint8_t *csf_hdr)
+{
+	if (*csf_hdr == HAB_CMD_HDR)
+		return sizeof(struct hab_hdr);
+
+	return HAB_HDR_LEN(*(const struct hab_hdr *)csf_hdr);
+}
+
+/*
+ * Check if CSF has Write data command
+ *
+ * If WRITE DATA command exists, then return failure
+ */
+static int csf_is_valid(int ivt_offset, ulong start_addr, size_t bytes)
+{
+	size_t offset = 0;
+	size_t cmd_hdr_len = 0;
+	size_t csf_hdr_len = 0;
+
+	const struct hab_ivt *ivt_initial = NULL;
+	const uint8_t *csf_hdr = NULL;
+	const uint8_t *end = NULL;
+	const uint8_t *start = (const uint8_t *)start_addr;
+
+	ivt_initial = (const struct hab_ivt *)(start + ivt_offset);
+
+	if (bytes != 0)
+		end = start + bytes - 1;
+	else
+		end = start;
+
+	/* Check that the CSF lies within the image bounds */
+	if ((start == 0) || (ivt_initial == NULL) ||
+	    (ivt_initial->csf == 0) ||
+	    !chk_bounds((const uint8_t *)ivt_initial->csf,
+			HAB_HDR_LEN(*(const struct hab_hdr *)ivt_initial->csf),
+			start, end)) {
+		puts("Error - CSF lies outside the image bounds\n");
+		return 0;
+	}
+
+	csf_hdr = (const uint8_t *)ivt_initial->csf;
+
+	if (*csf_hdr == HAB_CMD_HDR) {
+		csf_hdr_len = HAB_HDR_LEN(*(const struct hab_hdr *)csf_hdr);
+	} else {
+		puts("Error - CSF header command not found\n");
+		return 0;
+	}
+
+	/* Check for Write data command in CSF */
+	do {
+		switch (csf_hdr[offset]) {
+		case (HAB_CMD_WRT_DAT):
+			puts("Error - WRITE Data command found\n");
+			return 0;
+		default:
+			break;
+		}
+
+		cmd_hdr_len = get_csf_cmd_hdr_len(&csf_hdr[offset]);
+		if (!cmd_hdr_len) {
+			puts("Error - Invalid command length\n");
+			return 0;
+		}
+		offset += cmd_hdr_len;
+
+	} while (offset < csf_hdr_len);
+
+	/* Write Data command not found */
+	return 1;
+}
+
 void display_event(uint8_t *event_data, size_t bytes)
 {
 	uint32_t i;
@@ -196,6 +282,11 @@ uint32_t authenticate_image(uint32_t ddr_start, uint32_t image_size)
 			start = ddr_start;
 			bytes = ivt_offset + IVT_SIZE + CSF_PAD_SIZE;
 
+			puts("Check CSF for Write Data command before ");
+			puts("authenticating image\n");
+			if (!csf_is_valid(ivt_offset, start, bytes))
+				return result;
+
 #ifdef DEBUG_AUTHENTICATE_IMAGE
 			printf("\nivt_offset = 0x%x, ivt addr = 0x%x\n",
 			       ivt_offset, ddr_start + ivt_offset);
diff --git a/arch/arm/include/asm/arch-mx6/hab.h b/arch/arm/include/asm/arch-mx6/hab.h
index 38d817a..880fd43 100644
--- a/arch/arm/include/asm/arch-mx6/hab.h
+++ b/arch/arm/include/asm/arch-mx6/hab.h
@@ -41,6 +41,23 @@ enum hab_state {
 	HAB_STATE_MAX
 };
 
+struct __packed hab_hdr {
+	uint8_t tag;              /* Tag field */
+	uint8_t len[2];           /* Length field in bytes (big-endian) */
+	uint8_t par;              /* Parameters field */
+};
+
+struct hab_ivt {
+	struct hab_hdr hdr;
+	uint32_t entry;
+	uint32_t reserved1;
+	uint32_t dcd;
+	uint32_t boot_data;
+	uint32_t self;
+	uint32_t csf;
+	uint32_t reserved2;
+};
+
 /*Function prototype description*/
 typedef enum hab_status hab_rvt_report_event_t(enum hab_status, uint32_t,
 		uint8_t* , size_t*);
@@ -75,6 +92,14 @@ typedef void hapi_clock_init_t(void);
 
 #define HAB_CID_ROM 0 /**< ROM Caller ID */
 #define HAB_CID_UBOOT 1 /**< UBOOT Caller ID*/
+
+#define HAB_CMD_HDR       0xD4  /* CSF Header */
+#define HAB_CMD_WRT_DAT   0xCC  /* Write Data */
+
+#define HAB_HDR_LEN(hdr)				\
+		((size_t)(((const struct hab_hdr *)&(hdr))->len[0] << 8) \
+		 + (size_t)((const struct hab_hdr *)&(hdr))->len[1])
+
 /* ----------- end of HAB API updates ------------*/
 
 #endif
diff --git a/arch/arm/include/asm/arch-mx7/hab.h b/arch/arm/include/asm/arch-mx7/hab.h
index fa29c78..58ae7eb 100644
--- a/arch/arm/include/asm/arch-mx7/hab.h
+++ b/arch/arm/include/asm/arch-mx7/hab.h
@@ -41,6 +41,23 @@ enum hab_state {
 	HAB_STATE_MAX
 };
 
+struct __packed hab_hdr {
+	uint8_t tag;              /* Tag field */
+	uint8_t len[2];           /* Length field in bytes (big-endian) */
+	uint8_t par;              /* Parameters field */
+};
+
+struct hab_ivt {
+	struct hab_hdr hdr;
+	uint32_t entry;
+	uint32_t reserved1;
+	uint32_t dcd;
+	uint32_t boot_data;
+	uint32_t self;
+	uint32_t csf;
+	uint32_t reserved2;
+};
+
 /*Function prototype description*/
 typedef enum hab_status hab_rvt_report_event_t(enum hab_status, uint32_t,
 		uint8_t* , size_t*);
@@ -64,6 +81,14 @@ typedef void hapi_clock_init_t(void);
 
 #define HAB_CID_ROM 0 /**< ROM Caller ID */
 #define HAB_CID_UBOOT 1 /**< UBOOT Caller ID*/
+
+#define HAB_CMD_HDR       0xD4  /* CSF Header */
+#define HAB_CMD_WRT_DAT   0xCC  /* Write Data */
+
+#define HAB_HDR_LEN(hdr)				\
+		((size_t)(((const struct hab_hdr *)&(hdr))->len[0] << 8) \
+		 + (size_t)((const struct hab_hdr *)&(hdr))->len[1])
+
 /* ----------- end of HAB API updates ------------*/
 
 #endif
-- 
2.7.4

